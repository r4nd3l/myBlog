I"òŒ<h1 id="30-css-selectors">30 CSS Selectors</h1>
<blockquote>
  <p>Source: <a href="https://code.tutsplus.com/tutorials/the-30-css-selectors-you-must-memorize--net-16048">The 30 CSS Selectors You Must Memorize</a></p>
</blockquote>

<h2 id="css-selectors">CSS Selectors</h2>

<p>So you learned the base <code class="language-plaintext highlighter-rouge">id</code>, <code class="language-plaintext highlighter-rouge">class</code>, and <code class="language-plaintext highlighter-rouge">descendant</code> selectors‚Äîand then called it a day? If so, you‚Äôre missing out on an enormous level of flexibility. While many of the selectors mentioned in this article are part of the CSS3 spec, and are, consequently, only available in modern browsers, you owe it to yourself to commit these to memory.</p>

<h2 id="1-">1. *</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    * {
     margin: 0;
     padding: 0;
    }
</code></pre></div></div>

<p>Let‚Äôs knock the obvious ones out, for the beginners, before we move onto the more advanced selectors.</p>

<p>The star symbol will target every single element on the page. Many developers will use this trick to zero out the <code class="language-plaintext highlighter-rouge">margin</code>s and <code class="language-plaintext highlighter-rouge">padding</code>. While this is certainly fine for quick tests, I‚Äôd advise you to never use this in production code. It adds too much <em>weight</em> on the browser, and is unnecessary.</p>

<p>The <code class="language-plaintext highlighter-rouge">*</code> can also be used with child selectors.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #container * {
     border: 1px solid black;
    }
</code></pre></div></div>

<p>This will target every single element that is a child of the <code class="language-plaintext highlighter-rouge">#container</code> <code class="language-plaintext highlighter-rouge">div</code>. Again, try not to use this technique very much, if ever.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/star.html?_ga=2.93315613.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="2-x">2. #X</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    #container {
       width: 960px;
       margin: auto;
    }
</code></pre></div></div>

<p>Prefixing the hash symbol to a selector allows us to target by <code class="language-plaintext highlighter-rouge">id</code>. This is easily the most common usage, however be cautious when using <code class="language-plaintext highlighter-rouge">id</code> selectors.</p>

<blockquote>
  <p>Ask yourself: do I absolutely need to apply an <code class="language-plaintext highlighter-rouge">id</code> to this element in order to target it?</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">id</code> selectors are rigid and don‚Äôt allow for reuse. If possible, first try to use a tag name, one of the new HTML5 elements, or even a pseudo-class.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/id.html?_ga=2.71615891.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-1">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="3-x">3. .X</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .error {
      color: red;
    }
</code></pre></div></div>

<p>This is a <code class="language-plaintext highlighter-rouge">class</code> selector. The difference between <code class="language-plaintext highlighter-rouge">id</code>s and <code class="language-plaintext highlighter-rouge">class</code>es is that, with the latter, you can target multiple elements. Use <code class="language-plaintext highlighter-rouge">class</code>es when you want your styling to apply to a group of elements. Alternatively, use <code class="language-plaintext highlighter-rouge">id</code>s to find a needle-in-a-haystack, and style only that specific element.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/class.html?_ga=2.71615891.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-2">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<h2 id="4-x-y">4. X Y</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    li a {
      text-decoration: none;
    }
</code></pre></div></div>

<p>The next most comment selector is the <code class="language-plaintext highlighter-rouge">descendant</code> selector. When you need to be more specific with your selectors, you use these. For example, what if, rather than targeting <em>all</em> anchor tags, you only need to target the anchors which are within an unordered list? This is specifically when you‚Äôd use a descendant selector.</p>

<blockquote>
  <p><strong>Pro-tip</strong> - If your selector looks like <code class="language-plaintext highlighter-rouge">X Y Z A B.error</code>, you‚Äôre doing it wrong. Always ask yourself if it‚Äôs absolutely necessary to apply all of that <em>weight</em>.</p>
</blockquote>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/descend.html?_ga=2.71615891.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-3">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="5-x">5. X</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a { color: red; }
    ul { margin-left: 0; }
</code></pre></div></div>

<p>What if you want to target all elements on a page, according to their <code class="language-plaintext highlighter-rouge">type</code>, rather than an <code class="language-plaintext highlighter-rouge">id</code> or <code class="language-plaintext highlighter-rouge">class</code>name? Keep it simple, and use a type selector. If you need to target all unordered lists, use <code class="language-plaintext highlighter-rouge">ul {}</code>.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/tagName.html?_ga=2.63423791.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-4">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="6-xvisited-and-xlink">6. X:visited and X:link</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a:link { color: red; }
    a:visited { color: purple; }
</code></pre></div></div>

<p>We use the <code class="language-plaintext highlighter-rouge">:link</code> pseudo-class to target all anchors tags which have yet to be clicked on.</p>

<p>Alternatively, we also have the <code class="language-plaintext highlighter-rouge">:visited</code> pseudo class, which, as you‚Äôd expected, allows us to apply specific styling to only the anchor tags on the page which <em>have</em> been clicked on, or <em>visited</em>.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/links.html?_ga=2.63423791.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-5">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="7-x--y">7. X + Y</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul + p {
       color: red;
    }
</code></pre></div></div>

<p>This is referred to as an adjacent selector. It will select <em>only</em> the element that is immediately preceded by the former element. In this case, only the first paragraph after each <code class="language-plaintext highlighter-rouge">ul</code> will have red text.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/adjacent.html?_ga=2.63423791.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-6">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="8-x--y">8. X &gt; Y</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    div#container &gt; ul {
      border: 1px solid black;
    }
</code></pre></div></div>

<p>The difference between the standard <code class="language-plaintext highlighter-rouge">X Y</code> and <code class="language-plaintext highlighter-rouge">X &gt; Y</code> is that the latter will only select direct children. For example, consider the following markup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;div id="container"&gt;
       &lt;ul&gt;
          &lt;li&gt; List Item
            &lt;ul&gt;
               &lt;li&gt; Child &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt; List Item &lt;/li&gt;
          &lt;li&gt; List Item &lt;/li&gt;
          &lt;li&gt; List Item &lt;/li&gt;
       &lt;/ul&gt;
    &lt;/div&gt;
</code></pre></div></div>

<p>A selector of <code class="language-plaintext highlighter-rouge">#container &gt; ul</code> will only target the <code class="language-plaintext highlighter-rouge">ul</code>s which are direct children of the <code class="language-plaintext highlighter-rouge">div</code> with an <code class="language-plaintext highlighter-rouge">id</code> of <code class="language-plaintext highlighter-rouge">container</code>. It will not target, for instance, the <code class="language-plaintext highlighter-rouge">ul</code> that is a child of the first <code class="language-plaintext highlighter-rouge">li</code>.</p>

<p>For this reason, there are performance benefits in using the child combinator. In fact, it‚Äôs recommended particularly when working with JavaScript-based CSS selector engines.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/childcombinator.html?_ga=2.63423791.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-7">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="9-x--y">9. X ~ Y</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul ~ p {
       color: red;
    }
</code></pre></div></div>

<p>This sibling combinator is similar to <code class="language-plaintext highlighter-rouge">X + Y</code>, however, it‚Äôs less strict. While an adjacent selector (<code class="language-plaintext highlighter-rouge">ul + p</code>) will only select the first element that is <em>immediately</em> preceded by the former selector, this one is more generalized. It will select, referring to our example above, any <code class="language-plaintext highlighter-rouge">p</code> elements, as long as they follow a <code class="language-plaintext highlighter-rouge">ul</code>.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/generalcombinator.html?_ga=2.62777004.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-8">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="10-xtitle">10. X[title]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[title] {
       color: green;
    }
</code></pre></div></div>

<p>Referred to as an <em>attributes selector</em>, in our example above, this will only select the anchor tags that have a <code class="language-plaintext highlighter-rouge">title</code> attribute. Anchor tags which do not will not receive this particular styling. But, what if you need to be more specific? Well‚Ä¶</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes.html?_ga=2.62777004.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-9">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="11-xhreffoo">11. X[href=‚Äùfoo‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[href="http://net.tutsplus.com"] {
      color: #1f6053; /* nettuts green */
    }
</code></pre></div></div>

<p>The snippet above will style all anchor tags which link to __; they‚Äôll receive our branded green color. All other anchor tags will remain unaffected.</p>

<blockquote>
  <p>Note that we‚Äôre wrapping the value in quotes. Remember to also do this when using a JavaScript CSS selector engine. When possible, always use CSS3 selectors over unofficial methods.</p>
</blockquote>

<p>This works well, though, it‚Äôs a bit rigid. What if the link does indeed direct to Nettuts+, but, maybe, the path is <em>nettuts.com</em> rather than the full url? In those cases we can use a bit of the regular expressions syntax.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes2.html?_ga=2.62777004.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-10">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="12-xhrefnettuts">12. X[href*=‚Äùnettuts‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[href*="tuts"] {
      color: #1f6053; /* nettuts green */
    }
</code></pre></div></div>

<p>There we go; that‚Äôs what we need. The star designates that the proceeding value must appear <em>somewhere</em> in the attribute‚Äôs value. That way, this covers <em>nettuts.com</em>, <em>net.tutsplus.com,</em> and even <em>tutsplus.com</em>.</p>

<p>Keep in mind that this is a broad statement. What if the anchor tag linked to some non-Envato site with the string <em>tuts</em> in the url? When you need to be more specific, use <code class="language-plaintext highlighter-rouge">^</code> and <code class="language-plaintext highlighter-rouge">$</code>, to reference the beginning and end of a string, respectively.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes3.html?_ga=2.62777004.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-11">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="13-xhrefhttp">13. X[href^=‚Äùhttp‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[href^="http"] {
       background: url(path/to/external/icon.png) no-repeat;
       padding-left: 10px;
    }
</code></pre></div></div>

<p>Ever wonder how some websites are able to display a little icon next to the links which are external? I‚Äôm sure you‚Äôve seen these before; they‚Äôre nice reminders that the link will direct you to an entirely different website.</p>

<p>This is a cinch with the carat symbol. It‚Äôs most commonly used in regular expressions to designate the beginning of a string. If we want to target all anchor tags that have a <code class="language-plaintext highlighter-rouge">href</code> which begins with <code class="language-plaintext highlighter-rouge">http</code>, we could use a selector similar to the snippet shown above.</p>

<blockquote>
  <p>Notice that we‚Äôre not searching for <code class="language-plaintext highlighter-rouge">http://</code>; that‚Äôs unnecessary, and doesn‚Äôt account for the urls that begin with <code class="language-plaintext highlighter-rouge">https://</code>.</p>
</blockquote>

<p>Now, what if we wanted to instead style all anchors which link to, say, a photo? In those cases, let‚Äôs search for the <em>end</em> of the string.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes4.html?_ga=2.62816684.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-12">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="14-xhrefjpg">14. X[href$=‚Äù.jpg‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[href$=".jpg"] {
       color: red;
    }
</code></pre></div></div>

<p>Again, we use a regular expressions symbol, <code class="language-plaintext highlighter-rouge">$</code>, to refer to the end of a string. In this case, we‚Äôre searching for all anchors which link to an image ‚Äì or at least a url that ends with <code class="language-plaintext highlighter-rouge">.jpg</code>. Keep in mind that this certainly won‚Äôt work for <code class="language-plaintext highlighter-rouge">gifs</code> and <code class="language-plaintext highlighter-rouge">pngs</code>.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes5.html?_ga=2.62816684.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-13">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="15-xdata-foo">15. X[data-*=‚Äùfoo‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[data-filetype="image"] {
       color: red;
    }
</code></pre></div></div>

<p>Refer back to number eight; how do we compensate for all of the various image types: <code class="language-plaintext highlighter-rouge">png</code>, <code class="language-plaintext highlighter-rouge">jpeg</code>, <code class="language-plaintext highlighter-rouge">jpg</code>, <code class="language-plaintext highlighter-rouge">gif</code> ? Well, we could create multiple selectors, such as:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[href$=".jpg"],
    a[href$=".jpeg"],
    a[href$=".png"],
    a[href$=".gif"] {
       color: red;
    }
</code></pre></div></div>

<p>But, that‚Äôs a pain in the butt, and is inefficient. Another possible solution is to use custom attributes. What if we added our own <code class="language-plaintext highlighter-rouge">data-filetype</code> attribute to each anchor that links to an image?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;a href="path/to/image.jpg" data-filetype="image"&gt; Image Link &lt;/a&gt; 
</code></pre></div></div>

<p>Then, with that <em>hook</em> in place, we can use a standard attributes selector to target only those anchors.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a[data-filetype="image"] {
       color: red;
    }
</code></pre></div></div>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes6.html?_ga=2.62816684.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-14">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="16-xfoobar">16. X[foo~=‚Äùbar‚Äù]</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     a[data-info~="external"] {
       color: red;
    }
    
    a[data-info~="image"] {
       border: 1px solid black;
    }
</code></pre></div></div>

<p>Here‚Äôs a special one that‚Äôll impress your friends. Not too many people know about this trick. The tilda (<code class="language-plaintext highlighter-rouge">~</code>) symbol allows us to target an attribute which has a spaced-separated list of values.</p>

<p>Going along with our custom attribute from number fifteen, above, we could create a <code class="language-plaintext highlighter-rouge">data-info</code> attribute, which can receive a space-separated list of anything we need to make note of. In this case, we‚Äôll make note of external links and links to images ‚Äì just for the example.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    "&lt;a href="path/to/image.jpg" data-info="external image"&gt; Click Me, Fool &lt;/a&gt;
</code></pre></div></div>

<p>With that markup in place, now we can target any tags that have either of those values, by using the ~ attributes selector trick.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /* Target data-info attr that contains the value "external" */
    a[data-info~="external"] {
       color: red;
    }
    
    /* And which contain the value "image" */
    a[data-info~="image"] {
      border: 1px solid black;
    }
</code></pre></div></div>

<p>Pretty nifty, ay?</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/attributes7.html?_ga=2.158630330.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-15">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="17-xchecked">17. X:checked</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    input[type=radio]:checked {
       border: 1px solid black;
    }
</code></pre></div></div>

<p>This pseudo class will only target a user interface element that has been <em>checked</em> - like a radio button, or checkbox. It‚Äôs as simple as that.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/checked.html?_ga=2.158630330.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-16">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="18-xafter">18. X:after</h2>

<p>The <code class="language-plaintext highlighter-rouge">before</code> and <code class="language-plaintext highlighter-rouge">after</code> pseudo classes kick butt. Every day, it seems, people are finding new and creative ways to use them effectively. They simply generate content around the selected element.</p>

<p>Many were first introduced to these classes when they encountered the clear-fix hack.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    .clearfix:after {
        content: "";
        display: block;
        clear: both;
        visibility: hidden;
        font-size: 0;
        height: 0;
        }
    
    .clearfix { 
       *display: inline-block; 
       _height: 1%;
    }
</code></pre></div></div>

<p>This <em>hack</em> uses the <code class="language-plaintext highlighter-rouge">:after</code> pseudo class to append a space after the element, and then clear it. It‚Äôs an excellent trick to have in your tool bag, particularly in the cases when the <code class="language-plaintext highlighter-rouge">overflow: hidden;</code> method isn‚Äôt possible.</p>

<p>For another creative use of this, [refer to my quick tip on creating shadows][20].</p>

<blockquote>
  <p>According to the CSS3 Selectors specification, you should technically use the pseudo element syntax of two colons <code class="language-plaintext highlighter-rouge">::</code>. However, to remain compatible, the user-agent will accept a single colon usage as well. In fact, at this point, it‚Äôs smarter to use the single-colon version in your projects.</p>
</blockquote>

<h3 id="compatibility-17">Compatibility</h3>

<ul>
  <li>IE8+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="19-xhover">19. X:hover</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    div:hover {
      background: #e3e3e3;
    }
</code></pre></div></div>

<p>Oh come on. You know this one. The official term for this is <code class="language-plaintext highlighter-rouge">user action pseudo class</code>. It sounds confusing, but it really isn‚Äôt. Want to apply specific styling when a user hovers over an element? This will get the job done!</p>

<blockquote>
  <p>Keep in mind that older version of Internet Explorer don‚Äôt respond when the <code class="language-plaintext highlighter-rouge">:hover</code> pseudo class is applied to anything other than an anchor tag.</p>
</blockquote>

<p>You‚Äôll most often use this selector when applying, for example, a <code class="language-plaintext highlighter-rouge">border-bottom</code> to anchor tags, when hovered over.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a:hover {
     border-bottom: 1px solid black;
    }
</code></pre></div></div>

<blockquote>
  <p><strong>Pro-tip</strong> - <code class="language-plaintext highlighter-rouge">border-bottom: 1px solid black;</code> looks better than <code class="language-plaintext highlighter-rouge">text-decoration: underline;</code>.</p>
</blockquote>

<h3 id="compatibility-18">Compatibility</h3>

<ul>
  <li>IE6+ (In IE6, :hover must be applied to an anchor element)</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="20-xnotselector">20. X:not(selector)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    div:not(#container) {
       color: blue;
    }
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">negation</code> pseudo class is particularly helpful. Let‚Äôs say I want to select all divs, except for the one which has an <code class="language-plaintext highlighter-rouge">id</code> of <code class="language-plaintext highlighter-rouge">container</code>. The snippet above will handle that task perfectly.</p>

<p>Or, if I wanted to select every single element (not advised) except for paragraph tags, we could do:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    *:not(p) {
      color: green;
    }
</code></pre></div></div>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/not.html?_ga=2.63417775.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-19">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="21-xpseudoelement">21. X::pseudoElement</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    p::first-line {
       font-weight: bold;
       font-size: 1.2em;
    }
</code></pre></div></div>

<p>We can use pseudo elements (designated by <code class="language-plaintext highlighter-rouge">::</code>) to style fragments of an element, such as the first line, or the first letter. Keep in mind that these must be applied to block level elements in order to take effect.</p>

<blockquote>
  <p>A pseudo-element is composed of two colons: <code class="language-plaintext highlighter-rouge">::</code></p>
</blockquote>

<h4 id="target-the-first-letter-of-a-paragraph">Target the First Letter of a Paragraph</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    p::first-letter {
       float: left;
       font-size: 2em;
       font-weight: bold;
       font-family: cursive;
       padding-right: 2px;
    }
</code></pre></div></div>

<p>This snippet is an abstraction that will find all paragraphs on the page, and then sub-target only the first letter of that element.</p>

<p>This is most often used to create newspaper-like styling for the first-letter of an article.</p>

<h4 id="target-the-first-line-of-a-paragraph">Target the First Line of a Paragraph</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    p::first-line {
       font-weight: bold;
       font-size: 1.2em;
    }
</code></pre></div></div>

<p>Similarly, the <code class="language-plaintext highlighter-rouge">::first-line</code> pseudo element will, as expected, style the first line of the element only.</p>

<blockquote>
  <p>‚ÄúFor compatibility with existing style sheets, user agents must also accept the previous one-colon notation for pseudo-elements introduced in CSS levels 1 and 2 (namely, :first-line, :first-letter, :before and :after). This compatibility is not allowed for the new pseudo-elements introduced in this specification.‚Äù</p>
</blockquote>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/pseudoElements.html?_ga=2.63417775.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-20">Compatibility</h3>

<ul>
  <li>IE6+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="22-xnth-childn">22. X:nth-child(n)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    li:nth-child(3) {
       color: red;
    }
</code></pre></div></div>

<p>Remember the days when we had no way to target specific elements in a stack? The <code class="language-plaintext highlighter-rouge">nth-child</code> pseudo class solves that!</p>

<p>Please note that <code class="language-plaintext highlighter-rouge">nth-child</code> accepts an integer as a parameter, however, this is not zero-based. If you wish to target the second list item, use <code class="language-plaintext highlighter-rouge">li:nth-child(2)</code>.</p>

<p>We can even use this to select a variable set of children. For example, we could do <code class="language-plaintext highlighter-rouge">li:nth-child(4n)</code> to select every fourth list item.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nth.html?_ga=2.63417775.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-21">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
</ul>

<hr />

<h2 id="23-xnth-last-childn">23. X:nth-last-child(n)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    li:nth-last-child(2) {
       color: red;
    }
</code></pre></div></div>

<p>What if you had a huge list of items in a <code class="language-plaintext highlighter-rouge">ul</code>, and only needed to access, say, the third to the last item? Rather than doing <code class="language-plaintext highlighter-rouge">li:nth-child(397)</code>, you could instead use the <code class="language-plaintext highlighter-rouge">nth-last-child</code> pseudo class.</p>

<p>This technique works almost identically from number sixteen above, however, the difference is that it begins at the end of the collection, and works its way back.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthLast.html?_ga=2.63417775.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-22">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="24-xnth-of-typen">24. X:nth-of-type(n)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul:nth-of-type(3) {
       border: 1px solid black;
    }
</code></pre></div></div>

<p>There will be times when, rather than selecting a <code class="language-plaintext highlighter-rouge">child</code>, you instead need to select according to the <code class="language-plaintext highlighter-rouge">type</code> of element.</p>

<p>Imagine mark-up that contains five unordered lists. If you wanted to style only the third <code class="language-plaintext highlighter-rouge">ul</code>, and didn‚Äôt have a unique <code class="language-plaintext highlighter-rouge">id</code> to hook into, you could use the <code class="language-plaintext highlighter-rouge">nth-of-type(n)</code> pseudo class. In the snippet above, only the third <code class="language-plaintext highlighter-rouge">ul</code> will have a border around it.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/nthOfType.html?_ga=2.96985375.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-23">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
</ul>

<hr />

<h2 id="25-xnth-last-of-typen">25. X:nth-last-of-type(n)</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul:nth-last-of-type(3) {
       border: 1px solid black;
    }
</code></pre></div></div>

<p>And yes, to remain consistent, we can also use <code class="language-plaintext highlighter-rouge">nth-last-of-type</code> to begin at the end of the selectors list, and work our way back to target the desired element.</p>

<h3 id="compatibility-24">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="26-xfirst-child">26. X:first-child</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul li:first-child {
       border-top: none;
    }
</code></pre></div></div>

<p>This structural pseudo class allows us to target only the first child of the element‚Äôs parent. You‚Äôll often use this to remove borders from the first and last list items.</p>

<p>For example, let‚Äôs say you have a list of rows, and each one has a <code class="language-plaintext highlighter-rouge">border-top</code> and a <code class="language-plaintext highlighter-rouge">border-bottom</code>. Well, with that arrangement, the first and last item in that set will look a bit odd.</p>

<p>Many designers apply classes of <code class="language-plaintext highlighter-rouge">first</code> and <code class="language-plaintext highlighter-rouge">last</code> to compensate for this. Instead, you can use these pseudo classes.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html?_ga=2.96985375.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-25">Compatibility</h3>

<ul>
  <li>IE7+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="27-xlast-child">27. X:last-child</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul &gt; li:last-child {
       color: green;
    }
</code></pre></div></div>

<p>The opposite of <code class="language-plaintext highlighter-rouge">first-child</code>, <code class="language-plaintext highlighter-rouge">last-child</code> will target the last item of the element‚Äôs parent.</p>

<h3 id="example">Example</h3>

<p>Let‚Äôs build a simple example to demonstrate one possible use of these classes. We‚Äôll create a styled list item.</p>

<h4 id="markup">Markup</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;ul&gt;
       &lt;li&gt; List Item &lt;/li&gt;
       &lt;li&gt; List Item &lt;/li&gt;
       &lt;li&gt; List Item &lt;/li&gt;
    &lt;/ul&gt;
</code></pre></div></div>

<p>Nothing special here; just a simple list.</p>

<h4 id="css">CSS</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul {
     width: 200px;
     background: #292929;
     color: white;
     list-style: none;
     padding-left: 0;
    }
    
    li {
     padding: 10px;
     border-bottom: 1px solid black;
     border-top: 1px solid #3c3c3c;
    }
</code></pre></div></div>

<p>This styling will set a background, remove the browser-default padding on the <code class="language-plaintext highlighter-rouge">ul</code>, and apply borders to each <code class="language-plaintext highlighter-rouge">li</code> to provide a bit of depth.</p>

<p><img src="https://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/extraBorders.png" alt="" /></p>

<blockquote>
  <p>To add depth to your lists, apply a <code class="language-plaintext highlighter-rouge">border-bottom</code> to each <code class="language-plaintext highlighter-rouge">li</code> that is a shade or two darker than the <code class="language-plaintext highlighter-rouge">li</code>‚Äôs background color. Next, apply a <code class="language-plaintext highlighter-rouge">border-top</code> which is a couple shades <em>lighter</em>.</p>
</blockquote>

<p>The only problem, as shown in the image above, is that a border will be applied to the very top and bottom of the unordered list - which looks odd. Let‚Äôs use the <code class="language-plaintext highlighter-rouge">:first-child</code> and <code class="language-plaintext highlighter-rouge">:last-child</code> pseudo classes to fix this.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    li:first-child {
        border-top: none;
    }
    
    li:last-child {
       border-bottom: none;
    }
</code></pre></div></div>
<p><img src="https://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/fixed.png" alt="" /></p>

<p>There we go; that fixes it!</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstChild.html?_ga=2.96985375.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-26">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<p>Yep - IE8 supported <code class="language-plaintext highlighter-rouge">:first-child</code>, but not <code class="language-plaintext highlighter-rouge">:last-child</code>. Go figure.</p>

<hr />

<h2 id="28-xonly-child">28. X:only-child</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    div p:only-child {
       color: red;
    }
</code></pre></div></div>

<p>Truthfully, you probably won‚Äôt find yourself using the <code class="language-plaintext highlighter-rouge">only-child</code> pseudo class too often. Nonetheless, it‚Äôs available, should you need it.</p>

<p>It allows you to target elements which are the <em>only</em> child of its parent. For example, referencing the snippet above, only the paragraph that is the only child of the <code class="language-plaintext highlighter-rouge">div</code> will be colored, red.</p>

<p>Let‚Äôs assume the following markup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;div&gt;&lt;p&gt; My paragraph here. &lt;/p&gt;&lt;/div&gt;

    &lt;div&gt;
       &lt;p&gt; Two paragraphs total. &lt;/p&gt;
       &lt;p&gt; Two paragraphs total. &lt;/p&gt;
    &lt;/div&gt;
</code></pre></div></div>

<p>In this case, the second <code class="language-plaintext highlighter-rouge">div</code>‚Äôs paragraphs will not be targeted; only the first <code class="language-plaintext highlighter-rouge">div</code>. As soon as you apply more than one child to an element, the <code class="language-plaintext highlighter-rouge">only-child</code> pseudo class ceases to take effect.</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyChild.html?_ga=2.96985375.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-27">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="29-xonly-of-type">29. X:only-of-type</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    li:only-of-type {
       font-weight: bold;
    }
</code></pre></div></div>

<p>This structural pseudo class can be used in some clever ways. It will target elements that do not have any siblings within its parent container. As an example, let‚Äôs target all <code class="language-plaintext highlighter-rouge">ul</code>s, which have only a single list item.</p>

<p>First, ask yourself how you would accomplish this task? You could do <code class="language-plaintext highlighter-rouge">ul li</code>, but, this would target <em>all</em> list items. The only solution is to use <code class="language-plaintext highlighter-rouge">only-of-type</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul &gt; li:only-of-type {
       font-weight: bold;
    }
</code></pre></div></div>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/onlyOfType.html?_ga=2.37086240.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-28">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="30-xfirst-of-type">30. X:first-of-type</h2>

<p>The <code class="language-plaintext highlighter-rouge">first-of-type</code> pseudo class allows you to select the first siblings of its type.</p>

<h4 id="a-test">A Test</h4>

<p>To better understand this, let‚Äôs have a test. Copy the following mark-up into your code editor:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;div&gt;
       &lt;p&gt; My paragraph here. &lt;/p&gt;
       &lt;ul&gt;
          &lt;li&gt; List Item 1 &lt;/li&gt;
          &lt;li&gt; List Item 2 &lt;/li&gt;
       &lt;/ul&gt;

       &lt;ul&gt;
          &lt;li&gt; List Item 3 &lt;/li&gt;
          &lt;li&gt; List Item 4 &lt;/li&gt;
       &lt;/ul&gt;   
    &lt;/div&gt;
</code></pre></div></div>

<p>Now, without reading further, try to figure out how to target only <em>‚ÄúList Item 2‚Äù</em>. When you‚Äôve figured it out (or given up), read on.</p>

<h4 id="solution-1">Solution 1</h4>

<p>There are a variety of ways to solve this test. We‚Äôll review a handful of them. Let‚Äôs begin by using <code class="language-plaintext highlighter-rouge">first-of-type</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul:first-of-type &gt; li:nth-child(2) {
       font-weight: bold;
    }
</code></pre></div></div>

<p>This snippet essentially says, ‚Äúfind the first unordered list on the page, then find only the immediate children, which are list items. Next, filter that down to only the second list item in that set.</p>

<h4 id="solution-2">Solution 2</h4>

<p>Another option is to use the adjacent selector.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    p + ul li:last-child {
       font-weight: bold;
    }
</code></pre></div></div>

<p>In this scenario, we find the <code class="language-plaintext highlighter-rouge">ul</code> that immediately proceeds the <code class="language-plaintext highlighter-rouge">p</code> tag, and then find the very last child of the element.</p>

<h4 id="solution-3">Solution 3</h4>

<p>We can be as obnoxious or as playful as we want with these selectors.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ul:first-of-type li:nth-last-child(1) {
       font-weight: bold;   
    }
</code></pre></div></div>

<p>This time, we grab the first <code class="language-plaintext highlighter-rouge">ul</code> on the page, and then find the very first list item, but starting from the bottom! :)</p>

<p><a href="http://cdn.tutsplus.com/net/uploads/legacy/840_cssSelectors/selectors/firstOfType.html?_ga=2.37086240.1488460991.1553001117-779650368.1552747267">View Demo</a></p>

<h3 id="compatibility-29">Compatibility</h3>

<ul>
  <li>IE9+</li>
  <li>Firefox 3.5+</li>
  <li>Chrome</li>
  <li>Safari</li>
  <li>Opera</li>
</ul>

<hr />

<h2 id="30--1---">30. + 1 * + *</h2>

<p>The ‚Äòlobotomized‚Äô owls. This would, as with standard prescriptive styling, become verbose very quickly if we were to create rules for each different element pairing within the interface. Hence, we adopt the aforementioned universal selector, creating our owl face. The axiom is as follows: ‚ÄúAll elements in the flow of the document that proceed other elements must receive a top margin of one line.‚Äù</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  * + * {
	  margin-top: 1.5em;
  }
</code></pre></div></div>
<h5 id="completeness">COMPLETENESS</h5>
<p>Assuming that your paragraphs‚Äô <code class="language-plaintext highlighter-rouge">font-size</code> is 1 <code class="language-plaintext highlighter-rouge">em</code> and its <code class="language-plaintext highlighter-rouge">line-height</code> is 1.5, we just set a default margin of one line between all successive flow elements of all varieties occurring in any order. Neither we developers nor the folks building content for the project have to worry about any elements being forgotten and not adopting at least a standard margin when rendered one after the other. To achieve this the prescriptive way, we‚Äôd have to anticipate specific elements and give them individual margin values. Boring, verbose, and liable to be incomplete.</p>

<p>Instead of writing styles, we‚Äôve created a style axiom: an overarching principle for the layout of flow content. It‚Äôs highly maintainable, too; if you change the <code class="language-plaintext highlighter-rouge">line-height</code>, just change this singular <code class="language-plaintext highlighter-rouge">margin-top</code> value to match.</p>

<h5 id="contextual-awareness">CONTEXTUAL AWARENESS</h5>
<p>It‚Äôs better than that, though. By applying margin between elements only, we don‚Äôt generate any redundant margin (exposed glue) destined to combine with the padding of parent elements. Compare solution (a), which adds a top margin to all elements, with solution (b), which uses the owl selector.</p>

<p><img src="https://alistapart.com/wp-content/uploads/2014/10/owl_1.png" alt="" /></p>
<blockquote>
  <p>The diagrams in the left column show margin in dark grey and padding in light gray.</p>
</blockquote>

<p>Now consider how this behaves in regard to nesting. As illustrated, using the owl selector and just a margin-top value, no first or last element of a set will ever present redundant margin. Whenever you create a subset of these elements, by wrapping them in a nested parent, the same rules that apply to the superset will apply to the subset. No margin, regardless of nesting level, will ever meet padding. With a sort of algorithmic elegance, we protect against compound whitespace throughout our interface.</p>

<p><img src="https://alistapart.com/wp-content/uploads/2014/10/owl_2.png" alt="" /></p>

<p>This is eminently less verbose and more robust than approaching the problem unaxiomatically and removing the leftover glue after the fact, as Chris Coyier reluctantly proposed in ‚ÄúSpacing The Bottom of Modules‚Äù. It was this article, I should point out, that helped give me the idea for the lobotomized owl.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .module &gt; *:last-child,
  .module &gt; *:last-child &gt; *:last-child,
  .module &gt; *:last-child &gt; *:last-child &gt; *:last-child {
    margin: 0;
  }
</code></pre></div></div>
<p>Note that this only works having defined a ‚Äúmodule‚Äù context (a big ask of a content editor), and requires estimating possible nesting levels. Here, it supports up to three.</p>

<h5 id="exception-driven-design">Exception-driven design</h5>
<p>So far, we‚Äôve not named a single element. We‚Äôve simply written a rule. Now we can take advantage of the owl selector‚Äôs low specificity and start judiciously building in exceptions, taking advantage of the cascade rather than condemning it as other methods do.</p>

<h5 id="book-like-justified-paragraphs">BOOK-LIKE, JUSTIFIED PARAGRAPHS</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  p {
    text-align: justify;
  }

  p + p {
  margin-top: 0;
  text-indent: 2em;
  }
</code></pre></div></div>
<p>Note that only successive paragraphs are indented, which is conventional‚Äîanother win for the adjacent sibling combinator.</p>

<h5 id="compact-modules">COMPACT MODULES</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .compact * + * {
    margin-top: 0.75em;
  }
</code></pre></div></div>
<p>You can employ a little class-based object orientation if you like, to create a reusable style for more compact modules. In this example, all elements that need margin receive a margin of only half a line.</p>

<h5 id="widgets-with-positioning">WIDGETS WITH POSITIONING</h5>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  .margins-off &gt; * {
    margin-top: 0;
  }
</code></pre></div></div>
<p>The owl selector is an expressive selector and will affect widgets like maps, where everything is positioned exactly. This is a simple off switch. Increasingly, widgets like these will occur as web components where our margin algorithm will not be inherited anyway. This is thanks to the style encapsulation feature of Shadow DOM.</p>

<h5 id="the-beauty-of-ems">The beauty of ems</h5>
<p>Although a few exceptions are inevitable, by harnessing the em unit in our margin value, margins already adjust automatically according to another property: <code class="language-plaintext highlighter-rouge">font-size</code>. In any instances that we adjust font-size, the margin will adapt to it: one-line spaces remain one-line spaces. This is especially helpful when setting an increased or reduced body <code class="language-plaintext highlighter-rouge">font-size</code> via a <code class="language-plaintext highlighter-rouge">@media</code> query.</p>

<p>When it comes to headings, there‚Äôs still more good fortune. Having set heading font sizes in your stylesheet in <code class="language-plaintext highlighter-rouge">em</code>s, appropriate margin (leading whitespace) for each heading has been set without you writing a single line of additional code.</p>

<p><img src="https://alistapart.com/wp-content/uploads/2014/10/owl_3.png" alt="" /></p>

<h5 id="phrasing-elements">Phrasing elements</h5>
<p>This style declaration is intended to be inherited. That is how it, and CSS in general, is designed to work. However, I appreciate that some will be uncomfortable with just how voracious this selector is, especially after they have become accustomed to avoiding inheritance wherever possible.</p>

<p>I have already covered the few exceptions you may wish to employ, but, if it helps further, remember that phrasing elements with a typical display value of <code class="language-plaintext highlighter-rouge">inline</code> will inherit the top margin but be unaffected in terms of layout. Inline elements only respect horizontal margin, which is as specified and standard behavior across all browsers.</p>

<p><img src="https://alistapart.com/wp-content/uploads/2014/10/owl_4.png" alt="" /></p>

<p>If you find yourself overriding the owl selector frequently, there may be deeper systemic issues with the design. The owl selector deals with flow content, and flow content should make up the majority of your content. I don‚Äôt advise depending heavily on positioned content in most interfaces because they break implicit flow relationships. Even grid systems, with their floated columns, should require no more than a simple <code class="language-plaintext highlighter-rouge">.row &gt; *</code> selector applying <code class="language-plaintext highlighter-rouge">margin-top: 0</code> to reset them.</p>

<p><img src="https://alistapart.com/wp-content/uploads/2014/10/owl_5.png" alt="" /></p>

<hr />

:ET